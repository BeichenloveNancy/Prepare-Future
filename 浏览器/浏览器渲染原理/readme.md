# 浏览器渲染原理

渲染引擎
  火狐： Gecko
  谷歌、safari: webkit

1. 浏览器从网络中接收到html文件并转换为 DOM 树
> 当数据转化为字符串以后，浏览器会先将这些字符串通过词法分析转化为 标记，这个过程我们叫标记化

字节数据 ---> 字符串 ---> Token （标记，构成代码的最小单位）

当标记化结束后， 这些标记会接着转换为Node, 最后这些Node会根据不同 Node之前的联系
构建成一颗 DOM 树

2. 浏览器将CSS文件转化为 cssom树
这个过程中，浏览器会确定每一个节点的样式到底是什么，这个过程是很消耗资源的，因为样式可以自行设置，
也可以继承得来，所以这个过程中得递归 cssom树，然后确定具体的元素到底是什么样式

3. 生成渲染树
DOM树 + CSSOM树 但不是简单的合并，渲染树只会包含需要显示的节点，和这些节点的样式信息
如果节点是display:none；的话，就不会在渲染树中显示。

4. 渲染 ------> 先回流再重绘
根据渲染树来布局（回流-》计算DOM结构的几何信息） ，调用GPU绘制，合成图层显示在屏幕上。


# 为什么操作 DOM 慢？ 
**React、Vue使用数据驱动视图，引入虚拟DOM的概念，不直接操作DOM 不涉及到JS引擎和UI渲染引擎两个不相关线程之间的通信,不会开销额外的性能**
1. JS直接操作DOM 这其中涉及到两块内容，js是靠js引擎来执行的，而操作的Dom是靠渲染的引擎来执行的，这个操作势必会造成两个线程之间的通信，也就一定会开销额外的性能。操作的DOM次数一多，也就等同于一直在进行线程之间的通信。
2. 操作DOM会做重绘、回流的操作，也就造成了性能的开销。


# 插入几万个dom，如何实现页面不卡顿
解决这个问题的重点应该如何分批次渲染部分的DOM
使用requestAnimationFrame的方式去循环的插入dom（每16.6s执行一次）
另一种实现方式：虚拟滚动 只渲染可视区域，非可视区域完全不渲染，当用户滚动的时候去替换渲染的内容

# 什么情况会阻塞渲染？
1. html和css会阻塞渲染，所以我们应该降低一开始需要渲染文件的大小，并且扁平层级，优化选择器。
2. script标签的解析会导致暂停DOM的构建，解析完之后才会继续构建DOM，所以想要首屏渲染的越快越不能在首屏加载js，这也是为什么
script标签尽量放在body底部的原因。 （当script加上了defer这个属性时，就会默认把js放在html解析完成之后执行，所以script放哪都可以）
3. 对于没有任何依赖的js文件,可以加上async属性,表示js文件下载和解析是异步的,不会阻塞渲染。


# 重绘（repaint) 和 回流 （reflow)
  - 重绘
      需要改变外观而不影响布局，比如改变color就叫重绘
  - 回流
      布局或者几何属性需要改变

**回流必定会重绘 但重绘不一定会引发回流**

以下几个动作会导致性能问题：
  1. 改变window大小
  2. 改变字体
  3. 添加或删除样式
  4. 文字大小改变

你不知道的是：回流和重绘其实和 Event-loop有关
1. Eventloop执行完微任务后，会判断document是否需要更新，因为浏览器是60Hz的刷新率，每16.6ms回更新一次
2. 然后判断是否有resize或者scroll事件，有的话就会去触发事件，所以resize和scroll事件也是
至少16ms才会触发的
3. 判断是否触发了media query
4. 更新动画发送事件
5. 判断是否全屏
6. 执行requestAnimationFrame回调、
7. 执行 IntersectionObserver回调，该方法用来判断元素是否可见
8. 更新页面

以上就是一帧可能会干的事情

# 减少重绘和回流
1. 参考chonghui.html
2. 尽量不要用table布局，因为table中很小的改动就会造成整个table的重新布局
